TYPE "typeCommand"
VERSION : 0.1
   STRUCT
      length : UInt;
   END_STRUCT;

END_TYPE

FUNCTION_BLOCK "PtpPolling"
{ S7_Optimized_Access := 'TRUE' }
VERSION : 0.1
   VAR_INPUT 
      enable : Bool;   // Enable for executing polling operation
      reset : Bool;   // reset operation , rising edge active
      PORT : HW_ANY;   // HW identifier
      mode : USInt := 2;   // 0:no used;1:send only:2:receive only;3:proactive request mode;4passive response mode
      minInterval : Time := T#100ms;   // Minimum interval time between two transmitted frames
   END_VAR

   VAR_OUTPUT 
      status : Word;
      busy : Bool;
      error : Bool;
      done : Bool;
   END_VAR

   VAR_IN_OUT 
      sendBuffer : Variant;   // Send byte array
      recvBuffer : Variant;   // Receive byte array
      commands : Variant;   // Storing polling commands, array of typeCommand
   END_VAR

   VAR 
      instSend_P2P {InstructionName := 'Send_P2P'; LibVersion := '4.0'; S7_SetPoint := 'False'} : Send_P2P;   // send function
      instReceive_P2P {InstructionName := 'Receive_P2P'; LibVersion := '4.1'; S7_SetPoint := 'False'} : Receive_P2P;   // receive function
      statSendErrorStatus : Array[1..#MAX_CNT] of Word;   // Send fault status buffer, storing the state when a transmission fault occurs.
      statRecvErrorStatus : Array[1..#MAX_CNT] of Word;   // Receive fault status buffer, storing the state when a receive fault occurs
      statSendStatusIndex : UDInt;   // Latest Send Failure Status Index
      statRecvStatusIndex : UDInt;   // Latest Receive Failure Status Index
      statRecvBytesStatistics : UDInt;   // Received Byte Statistics
      statSendBytesStatistics : UDInt;   // Sent Byte Statistics
      statSendCnt : UDInt;   // Successful Send Count
      statRecvCnt : UDInt;   // Successful Receive Count
      statSendErrorCnt : UDInt;   // Send Fault Count
      statRecvErrorCnt : UDInt;   // Receive Fault Count
      statMaxSendTime : Time;   // Maximum time for completing the sending job
      statMaxRecvInterval : Time;   // Maximum interval for receiving jobs
      internal : Struct   // For internal use only
         delayTimer {InstructionName := 'TON_TIME'; LibVersion := '1.0'; S7_SetPoint := 'False'} : TON_TIME;
         startSendTime { S7_SetPoint := 'True'} : Time;
         lastRecvTime : Time;
         firstRecvTime : Time;
         state : Int;
         status : Word;
         done : Bool;
         busy : Bool;
         error : Bool;
         startupTimer : Bool;
      END_STRUCT;
   END_VAR

   VAR_TEMP 
      tmpCommands : Array[0..#LEGTH_OF_COMMAND_ARRAY] of "typeCommand";   // command type
      tmpDeltaTime : Time;
      tmpRet : Int;
      tmpDisableSend : Bool;
      tmpDisableRecv : Bool;
   END_VAR

   VAR CONSTANT 
      INIT : SInt := 0;
      START : SInt := 1;
      SEND : SInt := 2;
      RECV : SInt := 3;
      SUCCESS : SInt := 4;
      DELAY : SInt := 5;
      ERRO : SInt := -1;
      NO_USED : Word := 1;
      SENDBUFF_IS_NULL : Word := 2;
      RECVBUFF_IS_NULL : Word := 3;
      COMMANDS_NOT_ARRAY : Word := 4;
      COMMANDS_WRONG_TYPE : Word := 5;
      TEMP_COMMANDS_ARRAY_TOO_SHORT : Word := 6;
      RESET_MODE : Word := 7;
      SEND_ONLY : USInt := 1;
      RECV_ONLY : USInt := 2;
      PROACTIVE_REQUEST : USInt := 3;
      PASSIVE_RESPONSE : USInt := 4;
      MAX_CNT : USInt := 10;   // State Buffer Length
      LEGTH_OF_COMMAND_ARRAY : UInt := 9;   // length of commands
   END_VAR


BEGIN
	
	
	CASE #internal.#state OF
	    #INIT: // initialize
	        // check commands
	        IF #commands <> NULL THEN
	            IF IS_ARRAY(#commands) THEN
	                IF TypeOf(#commands) <> TypeOf(#tmpCommands) THEN
	                    #status := #COMMANDS_WRONG_TYPE;
	                    RETURN;
	                ELSIF CountOfElements(#commands) > #LEGTH_OF_COMMAND_ARRAY +1 THEN
	                    #status := #TEMP_COMMANDS_ARRAY_TOO_SHORT;
	                    RETURN;
	                END_IF;
	            ELSE
	                #status := #COMMANDS_NOT_ARRAY;
	                RETURN;
	            END_IF;
	        END_IF;
	        // check send and receive buffer
	        #tmpDisableSend := #sendBuffer = NULL;
	        #tmpDisableRecv := #recvBuffer = NULL;
	        CASE #mode OF
	            #SEND_ONLY: 
	                IF #tmpDisableSend THEN
	                    #status := #SENDBUFF_IS_NULL;
	                    RETURN;
	                END_IF;
	            #RECV_ONLY: 
	                IF #tmpDisableRecv THEN
	                    #status := #RECVBUFF_IS_NULL;
	                    RETURN;
	                END_IF;
	            #PROACTIVE_REQUEST, #PASSIVE_RESPONSE:
	                IF #tmpDisableSend THEN
	                    #status := #SENDBUFF_IS_NULL;
	                    RETURN;
	                ELSIF #tmpDisableRecv THEN
	                    #status := #RECVBUFF_IS_NULL;
	                    RETURN;
	                END_IF;
	            ELSE  
	                #status := #NO_USED;
	                RETURN;
	        END_CASE;
	        // initialize counter and arrays of error status 
	        #statMaxRecvInterval:=#statMaxSendTime:= t#0ms;
	        #statSendCnt := #statRecvCnt := #statSendErrorCnt := #statRecvErrorCnt := 0;
	        #statSendStatusIndex := #statRecvStatusIndex := 0;
	        #statRecvBytesStatistics := #statSendBytesStatistics := 0;
	        FILL_BLK(IN := 0,
	                 COUNT := #MAX_CNT,
	                 OUT => #statSendErrorStatus[1]);
	        #statRecvErrorStatus := #statSendErrorStatus;
	        #internal.status := 0;
	        #internal.#state := #START;
	        
	    #START:  // waiting for enable polling 
	        #instSend_P2P.REQ := 0;
	        #internal.status := 0;
	        #internal.startupTimer := #internal.done := #internal.error := #internal.busy := 0;
	        IF #reset THEN
	            #internal.#state := #INIT;
	            #status := #RESET_MODE;
	            RETURN;
	        END_IF;
	        IF #enable THEN
	            CASE #mode OF
	                #SEND_ONLY, #PROACTIVE_REQUEST:  
	                    #internal.state := #SEND;
	                    #internal.startSendTime:= TIME_TCK();
	                    #internal.busy := 1;
	                #RECV_ONLY, #PASSIVE_RESPONSE:  
	                    #internal.state := #RECV;
	                    #internal.busy := 1;
	            END_CASE;
	             
	            // Define different structures for typeCommands based on actual requirements.
	            // Example: Command arrays provide different send byte lengths.
	            REGION Custom Code Area
	                #tmpRet:=MOVE_BLK_VARIANT(SRC := #commands, COUNT := CountOfElements(#commands), SRC_INDEX := 0, DEST_INDEX := 0, DEST => #tmpCommands);
	                #instSend_P2P.LENGTH := #tmpCommands[#statSendCnt MOD #MAX_CNT].length;
	            END_REGION
	        ELSE
	            #internal.#state := #INIT;
	        END_IF;
	    #SEND:  // sending request or response to partner  
	        #instSend_P2P.REQ := 1;
	        IF #mode = #SEND_ONLY OR #mode = #PROACTIVE_REQUEST THEN
	            #internal.startupTimer := 1;
	        END_IF;
	        
	        IF #instSend_P2P.DONE THEN
	            #tmpDeltaTime := TIME_TCK() - #internal.startSendTime;
	            IF #statMaxSendTime <  #tmpDeltaTime THEN
	                #statMaxSendTime := #tmpDeltaTime;
	            END_IF;
	            #statSendCnt += 1;
	            #statSendBytesStatistics += #instSend_P2P.send_length;
	            CASE #mode OF
	                #SEND_ONLY, #PASSIVE_RESPONSE:  
	                    #internal.state := #SUCCESS;
	                #PROACTIVE_REQUEST:  
	                    #internal.state := #RECV;
	            END_CASE;
	        END_IF;
	        IF #instSend_P2P.ERROR THEN
	            #statSendErrorCnt += 1;
	            #internal.state := #ERRO;
	            #statSendStatusIndex := #statSendErrorCnt MOD #MAX_CNT + 1;
	            #internal.status := #statSendErrorStatus[#statSendStatusIndex] := #instSend_P2P.STATUS;
	        END_IF;
	    #RECV:  // waiting partner request or response 
	        IF #instReceive_P2P.NDR THEN
	            #statRecvCnt += 1;
	            IF #statRecvCnt = 1 THEN
	                #internal.lastRecvTime := TIME_TCK();
	            ELSE
	                #tmpDeltaTime:=TIME_TCK() - #internal.lastRecvTime;
	                IF #statMaxRecvInterval < #tmpDeltaTime THEN
	                    #statMaxRecvInterval := #tmpDeltaTime;
	                END_IF;
	            END_IF;
	            
	            #statRecvBytesStatistics += #instReceive_P2P.LENGTH;
	            CASE #mode OF
	                #RECV_ONLY, #PROACTIVE_REQUEST:  
	                    #internal.state := #SUCCESS;
	                #PASSIVE_RESPONSE:  
	                    #internal.state := #SEND;
	            END_CASE;
	        END_IF;
	        
	        IF #instReceive_P2P.ERROR THEN
	            #statRecvErrorCnt += 1;
	            #internal.state := #ERRO;
	            #statRecvStatusIndex := #statRecvErrorCnt MOD #MAX_CNT + 1;
	            #internal.status := #statRecvErrorStatus[#statRecvStatusIndex] := #instReceive_P2P.STATUS;
	        END_IF;
	    #SUCCESS: // success for job
	        #internal.state := #DELAY;
	    #DELAY:
	        IF #internal.delayTimer.Q OR #mode = #RECV_ONLY OR #mode = #PASSIVE_RESPONSE THEN
	            #internal.state := #START;
	            #internal.busy := 0;
	            #internal.done := 1;
	        END_IF;
	    #ERRO:  // job execute failed , retry the job
	        #internal.state := #START;
	        #internal.busy := 0;
	        #internal.error := 1;
	    ELSE  // error state
	        #internal.state := #START;
	        #internal.busy := 0;
	        #internal.error := 1;
	END_CASE;
	
	IF NOT #tmpDisableSend THEN
	    #instSend_P2P("PORT" := #PORT,
	                  BUFFER := #sendBuffer);
	END_IF;
	IF NOT #tmpDisableRecv THEN
	    #instReceive_P2P("PORT" := #PORT,
	                     BUFFER := #recvBuffer);
	END_IF;
	#internal.delayTimer(IN := #internal.startupTimer,
	                     PT := #minInterval);
	
	#busy := #internal.busy;
	#error := #internal.error;
	#done := #internal.done;
	#status := #internal.status;
	
END_FUNCTION_BLOCK

